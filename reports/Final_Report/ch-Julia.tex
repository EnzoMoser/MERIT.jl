\setcounter{chapter}{2}
\setcounter{section}{0}
\setcounter{subsection}{0}
\chapter*{Evaluating Programming Languages}
\addcontentsline{toc}{chapter}{Evaluating Programming Languages}
A wide array of libraries aimed towards researchers and data scientists tend to be written in high-level languages such
as Python and MATLAB. Their high-level syntax and open-source nature make them an attractive language to create and
share libraries. This is backed up by statistics collected by JetBrains in 2022 which showed that out of the 23,000
people surveyed for their Python usage, 53\% of these people used Python for some form of data science
\cite{PythonDevelopersSurvey}. MATLAB also reports similar statistics, mentioning that their software suite is used by
over 6500+ universities around the world for various purposes \cite{MATLABAcademia}. Julia is another programming
language that has been gaining interest in research communities due to having high-level syntax like Python and MATLAB
but also the performance that comes with low-level languages such as C. The Julia team conducted their own study of
1,329 individuals over a 3 month period in 2023 and found that 84\% of people surveyed used Julia for research or
teaching \cite{clasterJuliaUserDeveloper}. The prevalence of these programming languages in academia made them a
potential candidate for MERIT.jl. The sections that follow will contain an analysis of the advantages and
disadvantages of using each language.

\section{Python}
 Python's philosophy was code readability over all and this fact is complimented by its high-level syntax and
indentation requirements. It was first introduced towards the end of the 1980's by Guido van Rossum and has had an
expansive community ever since. The introduction of the PyPI Python Package Index in the late 2000's catapulted the new
20 year old language into the limelight by greatly simplifying the process of distributing libraries. Its success is
evident with over 20.4TB worth of Python libraries being hosted by PyPI \cite{indexPyPIStatistics}. However, several
drawbacks severely limit the usability of Python for high performance applications. Firstly, Python is an interpreted
language, meaning that at runtime, the Python interpreter reads the Python file line by line and calls the relevant
machine code. Due to this interpretation step, raw Python code is slow to run
\cite{baranyPythonInterpreterPerformance2014}. For this reason, many libraries that require high performance in Python
have a significant portion of their code written in C or C++, as demonstrated by their language breakdown in their respective GitHub repositories
\cite{Tensorflow, paszkePyTorch}. So developers who are concerned about speed have to be proficient in C and C++ as well
as Python, creating a high barrier of entry which goes against MERIT.jl's  goal of ``easily extensibility''.

Secondly, the Python Interpreter makes use of a runtime lock known as the Global Interpreter Lock (GIL) which makes
parallel processing in Python difficult \cite{ajitsariaWhatPythonGlobal}. Python implemented the GIL as a consequence of
their use of reference counting for memory management. Reference counting is a method where each object in Python gets
assigned a reference variable that keeps track of the number of references that point to that object. As references to
the object are created, the count goes up, as references are deleted or reach the end of their scope, the count goes
down. When this variable reaches zero, it becomes a flag for the object to be deleted. In some threaded applications,
references can get created or deleted by multiple threads, causing this counter to be updated simultaneously. In some
cases, this can cause the reference count to never reach zero leading to a memory leak, or reaching zero too early,
prematurely deleting the object. To combat this, Python created the GIL to act as a lock on the interpreter. Any Python
bytecode needs to first acquire a lock on the interpreter before it can be executed. This makes multithreading in Python
difficult and slower than it would be in other languages. So for these reasons, Python was rejected as the software of
choice.

\section{MATLAB}
MATLAB was another language that was considered. Developed in 1984, it became the goto software for many research
purposes due to its ease of use and intuitive operations on matrices and its multi-dimensional analogs. MATLAB also has
seen success in industry with one company estimating that it is used in over 57,811 companies
\cite{CompaniesUsingMATLAB}. However, MATLAB is an interpreted language like Python, meaning that it is slower than
compiled code. A study conducted by Aruoba and Fernández-Villaverde found that their MATLAB code ran about 3x slower
than the same code written in C++, highlighting just how big of a difference a compiler can make
\cite{aruobaComparisonProgrammingLanguages2018}. It should be noted that the same MATLAB code ran about 30.26x faster
than their Python implementation, implying that even though both are interpreted languages, the MATLAB interpreter is
much more optimized than the Python interpreter. But one of the biggest drawbacks by far, is the fact that MATLAB is a
license-based language. In order to use MATLAB, one must pay a yearly subscription of anywhere from €120 to €3,650
depending on the purpose for which it is used \cite{MATLABPricing}. This goes against the open-source nature of
MERIT.jl. The yearly licensing cost can be expensive for small research teams, barring them from contributing to the
library. Octave was briefly considered as it is a free and open-source competitor to MATLAB, but this idea was quickly
dropped when it became clear that Octave's main goal was compatibility with MATLAB scripts rather than absolute
performance. For these reasons, MATLAB was also rejected as the software of choice.

\section{Julia}
The third and final language considered was the Julia programming language. Julia was developed by Jeff Bezanson, Stefan
Karpinski, Viral B. Shah and Alan Edelman, and was first released to the public in 2012 \cite{bezansonWhyWeCreated12}.
The creators wanted a language that was as fast as C while also retaining the dynamism of high-level languages such as
Ruby and Python. The Just In Time (JIT) compiler employed by the Julia runtime compiles the high-level language syntax
into machine code allowing for large performance gains over other high-level languages. The aforementioned study found
that Julia was only 1.47x slower than the comparable C++ implementation \cite{aruobaComparisonProgrammingLanguages2018}.
Added to this speed, Julia offers features that are not available in Python or MATLAB such as parametric polymorphism,
multiple dispatch and efficient garbage collection. Julia also has native support for multiple parallel processing
paradigms such as GPU programming and multithreading, making it an appealing choice for people working on
high-performance compute clusters. One other feature that made Julia wildly popular was the native ability to call C and
Fortran libraries without having to create any special wrappers. These features allow Julia to have an ``It Just
Works!'' ideology, where libraries written in other supported languages as well as in Julia can all work together
without significant additions of ``glue-code''. As stated before Julia has already garnered an interest in academia,
this coupled with its performance made it a clear choice for MERIT.jl. The next chapter will discuss in detail the
various Julia features that were used in the library and how they contributed to the overall goal of answering the
research questions stated in the beginning.   