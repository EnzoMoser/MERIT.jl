\setcounter{chapter}{6}
\setcounter{section}{0}
\setcounter{subsection}{0}
\chapter*{Conclusions}
\addcontentsline{toc}{chapter}{Conclusions}
The success of the MARIA, Wavelia and TSAR clinical trials indicate that microwave imaging can provide a viable
alternative to traditional X-ray and ultrasound modalities. Aside from quantitative metrics, the subjective experiences
of the users also play a significant role in the success of an imaging modality. One qualitative study on women's
satisfaction after receiving a mammogram found that they felt pain and significant discomfort during the imaging
process, with one woman stating that she never showed up to her second appointment due to the pain experienced in the
first one \cite{engelmanWomenSatisfactionTheir2006}. Whereas a survey conducted on the participants of the Wavelia
clinical trial showed that 92\% of the women found the bed comfortable and would recommend the procedure to other women,
indicating that women feel safe and comfortable with this new imaging modality. While the hardware has progressed,
generalized software that can analyze the data from these systems has been lacking. Before the MERIT library created by
Dr. O'Loughlin for the MATLAB programming language, most available software was specific to a particular system or
created to answer a specific research question as was discussed at length in section \ref{MERITAsLibrary}. MERIT.jl was
motivated by this lack of software and was created to be an alternative for researchers who want to use the Julia
programming language in their studies.

MERIT was used to benchmark the MERIT.jl library in terms of performance and results. MERIT.jl can process the data from
the MERIT tutorial in under 12 seconds when running on a single thread on an i7-1185G7. It also demonstrates a
similar level of customizability and flexibility as the MATLAB library by allowing for custom delay and beamforming
functions, as well as allowing researchers to easily change the $\varepsilon$ parameter in the default delay function.
MERIT.jl also offers a form of reliability that is not seen in the MATLAB library through the introduction of a Point
data type. This Point type allowed for a distinction to be created between a collection of numbers that represent a
coordinate point, and a general collection of numbers. If the user were to incorrectly pass a collection of the point
type to a function in place of another argument, the Julia compiler would throw an error, thereby creating a level of
reliability. MERIT.jl also makes use of the multiple dispatch feature in Julia to hide implementation-specific details
from the end users. This is heavily used in the Point type to allow the inbuilt mathematical operators to work on the
Point type. This feature could also be used when the library needs to be extended to include different body parts. If
the library needed to accommodate the data from the study conducted by Zhao \textit{et al.}
\cite{gilmoreMicrowaveImagingHuman2013}, one would only have to create a ForearmScan struct subtyped from the Scan
abstract struct, and then overload the domain generation function. Users following the current pipeline in MERIT.jl
would not notice any difference as the compiler will handle dispatching the correct functions. This demonstrates another
one of the benefits that MERIT.jl has over the MATLAB version. The only way in MATLAB to achieve this would be to create
long chains of if-else statements that check the types of the provided input. Whereas in Julia, each specific
implementation of a function can be grouped under one name. In this way, functions in Julia can be considered as
concepts that encapsulate functional implementations. As was seen in section \ref{PlottedScans}, the MERIT.jl library
provides numerically identical outputs to the MATLAB implementation with an averaged MSE of $8.4417 \times 10^{-7}$,
showing that the MERIT.jl library can be a viable alternative to the MATLAB library.

The Julia programming language has proved to be an attractive choice for the developers of scientific libraries with
10,760 packages being tracked by JuliaHub relating to some field of science, engineering or mathematics. Its popularity
among these developers is a direct cause of the programming paradigms adopted by Julia, as was extensively discussed in
chapters 2 and 3. Julia allows developers to code with a high level, easy to learn, language while also using a JIT
compiler to generate highly optimized machine code at run time, even offering machine specific optimizations. This level
of optimization and performance is critical for tasks requiring large amounts of numerical computation. Moreover, Julia
offers native support for creating and working with matrices and their higher dimensional analogs, with operations that
are reminiscent of MATLAB-like syntax. This allows developers who may have a large scientific code base in MATLAB to easily
port their matrix operations to Julia while availing of the optimized linear algebra operations provided by the inbuilt
BLAS implementation. Additionally features such as multiple dispatch and the type hierarchy allow developers to
package multiple separate implementations of a particular function under one function name, whereas in other languages
such as MATLAB, this could only be achieved by long if-else blocks checking the type of the input arguments. The benefit
being code that is easily maintainable and easily extensible. As was seen in section \ref{JuliaScientificComputing}, the
multiple dispatch system allows other developers to create libraries that extend existing libraries in a way that is
transparent to the end user. This is demonstrated by the interplay between the DifferentialEquations.jl library and the
SciMLBase.jl library; users can use structures and functions from both libraries, which work together as if they were
part of the same library. This transparent integration is what allows packages in Julia to work seamlessly together,
meaning that communities of developers can create comprehensive collections of libraries around a particular topic
provided they agree on a common interface and standard.