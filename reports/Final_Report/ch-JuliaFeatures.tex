\setcounter{chapter}{3}
\setcounter{section}{0}
\setcounter{subsection}{0}
\chapter*{Julia Specific Features}
\addcontentsline{toc}{chapter}{Julia Specific Features}
\section{Multiple Dispatch}
Multiple Dispatch is a programming paradigm in which a function can be invoked based not only on the function name but
also on the type and order of input arguments. This is opposed to the single dispatch programming paradigm where the
function dispatched depends on a special argument placed before the function name. In almost all programming languages
this is the variable name for that class. For example, consider the following code: \hfill
\begin{lstlisting}[language=Julia]
# Defined in one library
Class Dog:
    name::string
    function says(a::string):
        print("The dog, $self.name says $a")
    end
end

billy = Dog("Billy")

# Defined in another library
Class Cat:
    name::string
    function says(a::string):
        print("The cat, $self.name says $a")
    end
end

kate = Cat("Kate")
\end{lstlisting}
If one wanted to call the \lstinline[language=Julia]{says} from the Cat or Dog class in the single dispatch paradigm,
one would have to write \lstinline[language=Julia]{billy.says("Hello World")} or
\lstinline[language=Julia]{kate.says("Hello World")}. This concept fits well with object-oriented programming languages
where classes are used to encapsulate concepts. However, a drawback of this system is that the compiler relies on the
user to remember which methods belong to the class and which methods are callable. Also since both the Cat and Dog
classes are defined in different libraries it is not clear how either developer could create a function where these
classes interact with each other without having to create a separate third library that implements compatibility code.

Multiple and its particular implementation in Julia solves some of these issues. In Julia, methods no longer belong to
classes, instead like in C they simply belong to a particular library, also known as a ``Module'' in Julia. Functions
defined in modules are usually exported such that they are available in the namespace of any other module that uses it.
This allows modules to use and overload functions and structures from other modules in a way that is completely
transparent to the end user.   
\begin{lstlisting}[language=Julia]
# Defined in library A
struct Dog{
    name::string
}

function says(pet::Dog, a::string)
    print("The dog, $pet.name says $a")
end  

# Defined in library B 
struct Cat{
    name::string
}

function encounters(petA, petB)
    print("$petA.name encounters $petB.name and $meets(petA, petB)")
end

function meets(petA::Cat, petB::Dog)
    return "hisses"
end

function meets(petA::Dog, petB::Cat)
    return "barks"
end

# Overloading function from library A
function says(pet::Cat, a::string)
    print("The cat, $pet.name says $a")
end


# Someone else using both libraries
billy = Dog("Billy")
kate = Cat("Kate")

says(billy, "Hello World")
says(kate, "Hello World")

encounters(kate, billy)
encounters(billy, kate)
\end{lstlisting}
In the above code block, library B overloads the \lstinline[language=Julia]{says} function to accept a struct of type
Cat. In addition to this, it also creates two new \lstinline[language=Julia]{meets} functions that handle the
interaction between the Cat and the Dog types, as well as an \lstinline[language=Julia]{encounters} function. A third
user can make use of both libraries as they did in the single dispatch case, but now they only have to call the function
name, rather than the function name prepended with the class variable name. In the case of the
\lstinline[language=Julia]{says} function call, the Julia compiler automatically dispatches the correct implementation
based on the type of the input argument. This is further exemplified in the final two function calls. As stated before
multiple dispatch is sensitive to both the type and order of the inputs. In the first call to the
\lstinline[language=Julia]{encounters} function, the \lstinline[language=Julia]{meets} function on line 19 will be
dispatched as the argument order was of type Cat and then Dog. Whereas in the second call to the
\lstinline[language=Julia]{encoutners} function, the \lstinline[language=Julia]{meets} function defined on line 23 will
be dispatched due to the reverse ordering of the types.

\begin{figure}[!h]
    \includegraphics[width=1\textwidth]{multipleDispatch.png}
    \centering
    \caption{Multiple Dispatch (top) vs Single Dispatch (bottom)} 
    \label{fig:multipleDispatch}
\end{figure}

\section{Type Heirarchy}
In Julia, all types are arranged in a tree-like structure and can be broadly classified into two categories, an Abstract
Type or a Concrete Type. Abstract types are the internal nodes of the type tree, having both parents and children, while
concrete types are the ``leaves'' of the tree, having parents but no children. Another notable difference between
abstract types and concrete types is that abstract types cannot be instantiated, they serve only as nodes in the type
graph. Shown in Figure \ref{fig:juliaTypeHeirarchy}, is the type hierarchy for the Integer type, abstract types are
highlighted in red, whereas concrete types are highlighted in blue. \hfill
\begin{figure}[t]
    \includegraphics[width=0.45\textwidth]{juliaTypeTree.png}
    \centering
    \caption{Type hierarchy for the Integer Type} 
    \label{fig:juliaTypeHeirarchy}
\end{figure}
\FloatBarrier
The type hierarchy not only provides a way to logically organize types but also tightly integrates with the multiple
dispatch system mentioned before. It is this pairing that allows Julia to fulfill its promise of easy and powerful
extensibility. The following example helps illustrate this further.
\begin{lstlisting}[language=Julia]
# Defined in library A
abstract type Animal end

struct Cat <: Animal
    name::string
end

struct Dog <: Animal
    name::string
end

function encounters(petA::Animal, petB::Animal)
    verb = meets(petA, petB)
    println("$(petA.name) meets $(petB.name) and $(verb)")
end

meets(petA::Animal, petB::Animal) = "passes by."
meets(petA::Cat, petB::Dog) = "hisses"
meets(petA::Dog, petB::Cat) = "barks"

# Defined in library B
struct Rabbit <: Animal
    name::String
end

whiskers = Cat("Whiskers")
chomper = Rabbit("Chomper")
encounters(whiskers, chomper)
\end{lstlisting}
Library A defines a type hierarchy with Cat and Dog being a subtype of the abstract Animal type. The library then
implements a series of \lstinline[language=Julia]{meets} functions and an \lstinline[language=Julia]{ecounters}
function, similar to the example in the previous section. However, unlike the example before, there is a new
\lstinline[language=Julia]{meets} which accepts an argument of type Animal. Library B, importing library A, defines a
Rabbit type that is a subtype of the Animal abstract type and then calls the encounters function from library A. The
dispatch system cannot execute the \lstinline[language=Julia]{meets} function from lines 18, since
\lstinline[language=Julia]{chompers} is not of type Dog. Instead, it executes the \lstinline[language=Julia]{meets}
function on line 17, since both \lstinline[language=Julia]{whiskers} and \lstinline[language=Julia]{chompers} are valid
Animal types. This highlights an important interplay between the type hierarchy and the multiple dispatch system, in
that when dispatching, the Julia compiler will select the function that is most specific across all its input arguments.
The developer of library A need not worry about all the other possible Animal types, or what their fields may contain,
they can create a generic \lstinline[language=Julia]{meets} function that accepts any subtype of the Animal class and
will execute successfully provided the subtyped class contains the fields being accessed. Neither developer has to worry
about the completeness of the other's implementation, provided developer B follows the standards set by developer A,
they can develop an extension to library A and trust that the two libraries will be comparable.

The concept of abstract types and subtypes is used heavily in MERIT.jl due to the constant pace of progression in the
field. Currently, most of the research in microwave imaging is centered around breast imaging and breast cancer, however
in 2013, a pilot study published in the International Journal of Biomedical Imaging found the use of microwave imaging
to be beneficial when imaging transverse sections of the forearm \cite{gilmoreMicrowaveImagingHuman2013}. As such the
library needs to be flexible enough to adapt to novel imaging domains. MERIT.jl is centered around the Scan abstract
type, from this, the BreastScan type is subtyped which holds all the information regarding the scan from a particular
breast. In order to incorporate the aforementioned study, one would have to create a ForearmScan type, subtyped from
Scan, which has a similar field name structure to the BreastScan type. In this way, MERIT.jl achieves extensive
flexibility and expandability which would not be possible in other languages. 
\begin{figure}[h!]
    \includegraphics[width=0.5\textwidth]{scanType.png}
    \centering
    \caption{Current type hierarchy in MERIT.jl} 
    \label{fig:scanType}
\end{figure}

\FloatBarrier
\section{Parametric Polymorphism}
Parametric polymorphism refers to the programming paradigm where a function can be made generic to the input argument
type. At compilation time, the compiler can strongly type the function based on the types of the input arguments.
Consider the simple example of an \lstinline[language=Julia]{addtwo(x)} function.
\begin{lstlisting}[language=Julia]
function addTwo(x::T) where {T <: Real}
    return x + T(2)
end
\end{lstlisting}
Instead of specifying a concrete type for \lstinline[language=Julia]{x}, it is parametrized by the variable
\lstinline[language=Julia]{T} which has an abstract type restriction on it. This implies that
\lstinline[language=Julia]{T}, and by extension \lstinline[language=Julia]{x}, can by any type that is a subtype of the
Real abstract type. If parametric polymorphism was not a Julia feature, this function would have to be duplicated 16
times to account for the various concrete types that are a subtype of Real (see Figure \ref{fig:juliaTypeHeirarchy}).

MERIT.jl uses this feature extensively due to the fact that the library needs to be agnostic to the type of the input
data. When instantiating the BreastScan struct the user can provide the types of the data that will be loaded and can
therefore set the internal data type of the struct. It would be impossible to support all 4,176 different permutations
of every type pairing, however, with parametric polymorphism, each function only needs to be defined once and the Julia
compiler will handle the rest. This means that researchers and developers don't have to worry about whether the library
functions can support the data type of their data, so long as it follows the type restriction set on the function, it
will produce an output, creating an intuitive and easy coding experience.  

\section{Type Stability}
Type Stability is a coding discipline that Julia recommends all code use. A function whose contained variables have a
consistent type for its lifetime is considered to be ``type stable'' or to have ``type stability''. Another way to think
about this, is that if the output type depends only on the input types, then the function is type stable. Consider the
following two functions: 
\begin{lstlisting}[language=Julia]
function unstable()
    x = 1
    for i = 1:10
        x /= rand()
    end
    return x
end

function stable()
    x = 1.0
    for i = 1:10
        x /= rand()
    end
    return x
end
\end{lstlisting}
Both functions have a variable, \lstinline[language=Julia]{x} which is divided 10 times by random floats and is returned
at the end of the function. However, based on the description above, the first function is considered to be ``Type
Unstable'' whereas the second function is considered to be ``Type Stable''. This is because in the first function the
type of \lstinline[language=Julia]{x} changes in the lifetime of the function (turns from Int64 to Float64). However in
the second function, the data type of \lstinline[language=Julia]{x} stays as a Float64 throughout the lifetime of the
function. The notion of type stability is important as it allows the Julia compiler to perform optimizations based on
the known data type of the variables at compile time. For type unstable functions, their unstable variables default to
type Any, ergo forgoing any optimizations. These optimizations are evident when benchmarking the functions above. This
was performed using the \lstinline[language=Julia]{@benchmark} macro from the BenchmarkTools module. Both functions were
run multiple times to ensure that only the compiled versions of the functions were executed rather than the interpreted
version. These benchmarks showed that on average the type unstable function ran 1.87x slower than the type stable
function (573.355ns and 306.178ns respectively). These performance gains become significant when considering the many
millions of function calls required to generate an output in MERIT.jl. Consider just the distance calculations required
between an $8cm$ radius breast whose domain is discretized with a resolution of $0.25cm$ and an antenna array made of 60
antennas; this equates to roughly 4.2M calculations alone for each image. Performing this on a type unstable function
would take far too long to compute, rendering the library unusable. Herein lies one of the drawbacks of writing Julia
code, namely the ease at which an inexperienced developer can write type unstable functions. In the simple case above,
the cause for the type instability is evident, however, with larger more complex functions it can be hard to narrow down
the cause for the instability. Creating performant code in these situations requires advanced knowledge of the language,
raising the barrier to entry. However, the language offers the \lstinline[language=Julia]{@code_warntype} macro that can
analyze sections of code and indicate, but not fix, places of instability where the compiler fails to infer the data
type of the variable. This tool can considerably benefit developers of MERIT.jl to ensure that any extensions written
for the language remain in line with its philosophy of performance.  

\section{Closure}
Closure in programming refers to the practice of calling a function A that returns a function B which has some
information about the variables contained in the scope of function A. Consider the following simple example:
\begin{lstlisting}[language=Julia]
function addX(x)
    scalar = x
    function calc_(a)
        return a + scalar
    end
end

add5 = addX(5)
add7 = addX(7)

add5(2)  # Will return 7
add7(10) # Will return 17
\end{lstlisting}
Defined above is a function called \lstinline[language=Julia]{addX} which accepts an input \lstinline[language=Julia]{x}
and assigns it to a variable \lstinline[language=Julia]{scalar}, before constructing and returning the function
\lstinline[language=Julia]{calc_}. This can be beneficial as it allows developers to create a family of functions that
are parametrized by their input variable. MERIT.jl makes use of closure in the \lstinline[language=Julia]{get_delys} in
the Breamform.jl file (for more information see the GitHub link in the Introduction). Earlier sections showed how
$\epsilon$ is a free parameter in the beamforming equations, one that researchers would be changing frequently to find
the optimal parameter for each particular scan. Implementing this feature fulfills one of the other tenets of MERIT.jl
which was to create flexibility and customizability in the functions where it was required. It must be noted that the
captured variable, in the above case \lstinline[language=Julia]{scalar}, must never be reassigned, otherwise, the
compiler will not be able to infer the data types leading to type unstable code, and by extension all the negative
consequences mentioned in the previous section.

\section{Type Safety}
Type Safety refers to a program or language's ability to detect and discourage errors that arise from performing
operations on the wrong data type. For example in Julia, it is simple to add two numeric types, but performing the same
operation on two strings would yield an error, since the summation operator is not defined for two string types. This
offers some level of protection against illegal operations, but there are many cases where the type of the variables
agree with the operation being performed, but their semantic meaning disagrees. The example below will illustrate this
idea.
\begin{lstlisting}[language=Julia]
function calcSpeed(dist::Vector{T}, t::Vector{T}) where {T <: Real}
    return dist ./ t
end

#################################################### 
distance = rand(1, 100)
time = rand(1, 100)
calcSpeed(distance, time)   # Will compute the speed

#################################################### 
distance = rand(1, 100)
time = rand(ComplexF64,1, 100)

# Will throw an error since there is a type mismatch
calcSpeed(distance, time)  

#################################################### 
distance = rand(1, 100)
time = rand(1, 100)

# Will compute the wrong answer, but no error gets thrown
calcSpeed(time, distance) 
\end{lstlisting}
In the code block above \lstinline[language=Julia]{calcSpeed} accepts a vector of distance and time and returns the
associated speeds. Executing line 8, as expected returns the calculated speeds correctly. Executing line 12 will throw a
type error since ComplexF64 is not a subtype of Real. Line 22 however, will execute and return successfully even though
the wrong answer is returned, as the arguments were provided in the wrong positional order. This is because compilers
can only make inferences regarding the legality of a statement based solely on the concrete types of its arguments
rather than their semantic meaning in the context of the function being executed. However, the chance of variables being
incorrectly passed positionally can be negated by creating lightweight types that encode this semantic information in
their type name. In the above case, it would mean creating a ``distance'' type and a ``time'' type that act as wrappers
around a numerical concrete type. This way when line 22 is executed, instead of returning an incorrect answer, the
compiler will raise an error as the ``time'' and ``distance'' types were provided in the wrong order.

The MERIT.jl library exemplifies the idea of ``strong'' type safety through its implementation of the Point data type.
The Point type is an abstract type from which the Point3 and Point2 concrete type subsets. These are lightweight
wrappers around a grouping of 3 and 2 numerical types respectively and serve the purpose of being a 3D and 2D point.
\begin{lstlisting}[language=Julia]
abstract type Point end

# xyz can be any data type that is a subset of Real
mutable struct Point3{T <: Real} <: Point
    x::T
    y::T
    z::T 
end

mutable struct Point2{T <:  Real} <: Point
    x::T
    y::T
end
\end{lstlisting}
Due to the custom nature of these data types, the inbuilt operators could not be used on them. So in addition, MERIT.jl
had to extend the in-built operators using the concepts of multiple dispatch and parametric polymorphism as mentioned
before such that these types could be useful. The full suite of implemented operators can be found in the GitHub
repository. Every function in the library that needs to work with points accepts a collection of a Points subtype
rather than a collection of numbers. This way no other collection of numbers can be erroneously passed in place of the
Points subtypes. Some edge cases still exist however, there is nothing stopping a user from incorrectly passing a
collection of points describing antenna locations to an argument which is for points from the imaging domain. Even
though this issue still exists, clear and easy to understand documentation should make this a nonissue. Due to time
constraints on the project, the entire library could not be made ``strongly'' typed, however, the Points type acts as s
template that could be used to eventually strongly type the entire library

\section{Customizability}
The customizability of the MERIT.jl library has been demonstrated extensively in the previous sections. However, nowhere
is this exemplified more than in the BreastScan struct. The entire library is built around the use of the Scan structs.
These structs encapsulate all the information about a particular Scan, including all the required information about the
machine that was used to conduct the scan. Most importantly each scan struct is recommended to have two function pointer
fields which will reference the delay function and the beamforming function to be used in the beamforming process.
During the setup process, researchers can easily swap out the delay function or the beamforming function used with other
relevant functions from the library or with their own functions. In order to work with the one-call data processing
pipeline in MERIT.jl, researchers just need to ensure that their delay and beamformer functions follow these templates:
\begin{lstlisting}[language=Julia]
function delay_template(relative_permiativity)
    # Capture the relatively_permiativity
    
    # Create a delay function
    function calc_(channels, antenna, domain_points):
        #calculate and return a time matrix
        #Size = (1 x #Channels x #Points)
    end
end

function beamformer(delayed_signals)
    #Do some processing
    #return should be of size (1 x 1 x #Points)
end
\end{lstlisting}
These templates allow for a lot of flexibility and are really where MERIT.jl shines in comparison to its MATLAB
counterpart. Researchers who just want to benchmark new algorithms against already established ones just need to follow
these templates and they can be guaranteed that their functions will ``just work'' with the one-call data processing
pipeline. If their functions also follow the rules of type stability mentioned in previous sections, they can also have
some reasonable guarantees that any slowdowns are caused by their implementations rather than the lack of compiler
optimizations for type unstable code.

